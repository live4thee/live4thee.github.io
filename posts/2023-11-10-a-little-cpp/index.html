<!DOCTYPE html>
<html lang="en">
  <head>
    <title>A Little C&#43;&#43; | Life of a Programmer</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="好久没用 C&#43;&#43; 了，当项目里重度使用现代 C&#43;&#43;（c&#43;&#43;11 以及后续标准） 的新特性时，就有点力不从心 &ndash; 书到用时方恨少。 template &lt;typename... A&gt; void set(A&amp;&amp;... a) noexcept { assert(_u.st == state::future); new (this) future_state(ready_future_marker(), std::forward&lt;A&gt;(a)...);">
<meta name="generator" content="Hugo 0.131.0">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />








  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
	  <a class="button" href="">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">A Little C&#43;&#43;</h1>

    <div class="tip">
        <time datetime="2023-11-10 11:30:45 &#43;0800 CST">Nov 10, 2023</time>
        <span class="split">
          ·
        </span>
        <span>
          1849 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          4 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#parameter-pack">parameter pack</a></li>
    <li><a href="#l-value--r-value">l-value &amp; r-value</a>
      <ul>
        <li><a href="#r-value-references">r-value references</a></li>
        <li><a href="#move-semantics">move semantics</a></li>
        <li><a href="#copy-ctor--move-ctor">copy ctor &amp; move ctor</a></li>
      </ul>
    </li>
    <li><a href="#stdforward">std::forward</a></li>
    <li><a href="#newthis">new(this)</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>好久没用 <code>C++</code> 了，当项目里重度使用现代 <code>C++</code>（<code>c++11</code> 以及后续标准）
的新特性时，就有点力不从心 &ndash; 书到用时方恨少。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... A<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> set(A<span style="color:#f92672">&amp;&amp;</span>... a) <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>  assert(_u.st <span style="color:#f92672">==</span> state<span style="color:#f92672">::</span>future);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">new</span> (<span style="color:#66d9ef">this</span>) future_state(ready_future_marker(), std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>(a)...);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码来自<a href="https://github.com/scylladb/seastar/blob/master/include/seastar/core/future.hh#L622" target="_blank" rel="noopener">Seastar</a>,
是在 <code>future_state</code> 上实现了 <code>set</code> 方法。</p>
<h2 id="parameter-pack">parameter pack <a href="#parameter-pack" class="anchor">🔗</a></h2><p>我们知道 C 里面有变长参数，比如 <code>printf</code> 的原型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">printf</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>format, ...);
</span></span></code></pre></div><p>C++ 模板类型后面的跟三个点是 C++11 里引入的模板参数包 (<a href="https://en.cppreference.com/w/cpp/language/parameter_pack" target="_blank" rel="noopener">template parameter pack</a>). 比如，以 C++11 风格定义一个 Tuple 模板：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Types<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Tuple</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Tuple<span style="color:#f92672">&lt;&gt;</span> t0;           <span style="color:#75715e">// Types contains no arguments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> t1;        <span style="color:#75715e">// Types contains one argument: int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> t2; <span style="color:#75715e">// Types contains two arguments: int and float
</span></span></span></code></pre></div><p>既然有 <code>pack</code>, 那么相应的就有 <code>unpack</code> 或者 <code>expansion</code>, 直接看<a href="https://en.cppreference.com/w/cpp/language/parameter_pack" target="_blank" rel="noopener">标准</a>。</p>
<h2 id="l-value--r-value">l-value &amp; r-value <a href="#l-value--r-value" class="anchor">🔗</a></h2><p>左值和右值是 C 里面就有的<a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c" target="_blank" rel="noopener">概念</a>，“左”和“右” 是赋值操作符 “=” 的左侧和右侧。左值可被赋值，而右值一般没有内存地址，不可被赋值。简单来说，左值是指可以取地址的、具有持久性的对象，而右值是指不能取地址的、临时生成的对象。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div><p>这里 <code>a</code> 是左值（<code>a+0</code> 是右值），<code>10</code> 是右值，可能只会在汇编代码的立即数中出现，临时存放在某个寄存器而不是内存中。在 C++ 里，下面的代码无法编译成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span></code></pre></div><p>报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’
</span></span></code></pre></div><p>传统 C++ 代码中，这里改成常量左值引用就可以。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e">// ok. bind a const lvalue to an rvalue
</span></span></span></code></pre></div><h3 id="r-value-references">r-value references <a href="#r-value-references" class="anchor">🔗</a></h3><p><code>T&amp;&amp; v</code> 的意思是：<code>v</code> 是一个右值引用。右值引用是 C++11 引入的概念，并且，
右值也可以被修改！比如，下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;      <span style="color:#75715e">// ok. rvalue reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>b <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;           <span style="color:#75715e">// ok. `b&#39; 可以被修改！
</span></span></span></code></pre></div><p>这<a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" target="_blank" rel="noopener">有啥好处</a>呢？用来实现 move semantics, 提高性能。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h3 id="move-semantics">move semantics <a href="#move-semantics" class="anchor">🔗</a></h3><p><code>Move semantics</code> 的核心要素是避免拷贝开销。</p>
<blockquote>
<p>Move semantics is a new way of moving resources around in an optimal
way by avoiding unnecessary copies of temporary objects, based on
rvalue references.</p>
</blockquote>
<p>C++ 有一个 <a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C&#43;&#43;_programming%29" target="_blank" rel="noopener">Rules of Three</a>,
就是说当某个类需要管理动态内存时，最好显式地实现三个成员方法：</p>
<ol>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>重载拷贝赋值运算符(copy assignment operator)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Foo f1;      <span style="color:#75715e">// regular constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo f2 <span style="color:#f92672">=</span> f1; <span style="color:#75715e">// copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo <span style="color:#a6e22e">f3</span>(f1);  <span style="color:#75715e">// copy constructor (alternate syntax)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo f4;
</span></span><span style="display:flex;"><span>f4 <span style="color:#f92672">=</span> f1;     <span style="color:#75715e">// copy assignment operator
</span></span></span></code></pre></div><p>一般来说，拷贝构造函数、重载赋值操作符有类似如下逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo(<span style="color:#66d9ef">const</span> Foo<span style="color:#f92672">&amp;</span> rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[rhs.m_size];  <span style="color:#75715e">// 初始化内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>copy(rhs.m_data, rhs.m_data <span style="color:#f92672">+</span> rhs.m_size, m_data); <span style="color:#75715e">// 复制数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  m_size <span style="color:#f92672">=</span> rhs.m_size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// assignment operator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Foo<span style="color:#f92672">&amp;</span> rhs) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>rhs) <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;  <span style="color:#75715e">// 避免自我赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">delete</span>[] m_data;                <span style="color:#75715e">// 释放已有内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[rhs.m_size];   <span style="color:#75715e">// 分配新内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>copy(rhs.m_data, rhs.m_data <span style="color:#f92672">+</span> rhs.m_size, m_data); <span style="color:#75715e">// 复制数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  m_size <span style="color:#f92672">=</span> rhs.m_size;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>两者的共同特征有：</p>
<ol>
<li>作为输入参数的被复制对象都是以 <code>const</code> 引用传入；</li>
<li>作为输出对象，其管理的内存都是复制了一份，源对象的内容没有改动。</li>
</ol>
<h3 id="copy-ctor--move-ctor">copy ctor &amp; move ctor <a href="#copy-ctor--move-ctor" class="anchor">🔗</a></h3><p>如果代码里存在这样的调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 注意: 这里显然不能返回 Foo&amp;, 否则将会引用一个已经释放的本地变量。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo <span style="color:#a6e22e">createFoo</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Foo(n);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于这段代码，<code>Foo f = createFoo(10);</code> 将会造成若干数据拷贝：<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<ul>
<li><code>Foo(n)</code> 产生一次构造函数</li>
<li><code>return</code> 产生一次拷贝构造函数</li>
<li><code>Foo f = ...</code> 产生一次拷贝构造函数</li>
</ul>
<p>为了解决临时拷贝的开销，c++11 引入了 <code>move semantics</code>: 传递数据的地址
（而不是内容本身）。因此，c++11 额外定义了 <code>move constructor</code> 以及 <code>move assignment constructor</code>. 入参都是 <code>rvalue reference</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Foo(Foo<span style="color:#f92672">&amp;&amp;</span> other) {
</span></span><span style="display:flex;"><span>  m_data <span style="color:#f92672">=</span> other.m_data;   <span style="color:#75715e">// 直接保存地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  m_size <span style="color:#f92672">=</span> other.m_size;
</span></span><span style="display:flex;"><span>  other.m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;  <span style="color:#75715e">// 所有权转移到了新对象，避免被释放多次。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  other.m_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Foo<span style="color:#f92672">&amp;&amp;</span> other) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>other) <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">delete</span>[] m_data;         <span style="color:#75715e">// 先释放已有内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  m_data <span style="color:#f92672">=</span> other.m_data;   <span style="color:#75715e">// 直接保存地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  m_size <span style="color:#f92672">=</span> other.m_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  other.m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;  <span style="color:#75715e">// 避免释放多次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  other.m_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Foo <span style="color:#a6e22e">createFoo</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Foo(n); <span style="color:#75715e">// 此时会使用 move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  Foo f1;      <span style="color:#75715e">// regular constructor, 不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Foo f2 <span style="color:#f92672">=</span> f1; <span style="color:#75715e">// copy constructor, 不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Foo f3(f1);  <span style="color:#75715e">// copy constructor (alternate syntax), 不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Foo f4;
</span></span><span style="display:flex;"><span>  f4 <span style="color:#f92672">=</span> f1;     <span style="color:#75715e">// copy assignment operator, 不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  f4 <span style="color:#f92672">=</span> createFoo(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">// move assignment.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>前面我们看到 <code>createFoo()</code> 因为编译器的 RVO 优化，使得看起来即使不实现<code>move constructor</code> 也无伤大雅。但是，我们其实也可以通过 <code>move semantics</code> 偷窃一个入参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  Foo <span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">1000</span>); <span style="color:#75715e">// f1 is an lvalue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Foo <span style="color:#a6e22e">f2</span>(f1);   <span style="color:#75715e">// copy-constructor invoked (because of lvalue in input)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Foo <span style="color:#a6e22e">f3</span>(std<span style="color:#f92672">::</span>move(f1)); <span style="color:#75715e">// move-constructor invoked
</span></span></span></code></pre></div><p>注意：当 <code>f3</code> 偷窃了来自 <code>f1</code> 的数据之后，后者的指针会被设为<code>nullptr</code>!<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> 看起来有点吓人，因此以下是一些忠告：</p>
<ul>
<li>为 <code>move constructor</code> 以及 <code>move assignment constructor</code> 加上<code>noexcept</code>. 这两个构造函数不应该涉及分配资源。</li>
<li>为了避免示例中的重复代码，考虑使用 <a href="https://stackoverflow.com/a/3279550/3296421" target="_blank" rel="noopener">copy-and-swap</a>.</li>
<li>实现完美转发(perfect forwarding)。<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></li>
</ul>
<h2 id="stdforward">std::forward <a href="#stdforward" class="anchor">🔗</a></h2><p><a href="https://en.cppreference.com/w/cpp/utility/forward" target="_blank" rel="noopener">std::forward</a> 也是
C++11 引入的。它的作用是根据传入的参数，决定将参数以左值引用还是右值引用的方式进行转发。使用左值还是右值的引用，决定转发后调用构造函数还是移动构造函数。详情参考<a href="https://www.justsoftwaresolutions.co.uk/cplusplus/rvalue_references_and_perfect_forwarding.html" target="_blank" rel="noopener">完美转发示例</a>，<a href="https://stackoverflow.com/a/3582313/3296421" target="_blank" rel="noopener">示例2</a>，
以及背后的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm" target="_blank" rel="noopener">原理</a>。</p>
<h2 id="newthis">new(this) <a href="#newthis" class="anchor">🔗</a></h2><p>用来调用指定对象的构造函数，类似拷贝构造函数的行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">base</span> {
</span></span><span style="display:flex;"><span>  base() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;base&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">derived</span> <span style="color:#f92672">:</span> base {
</span></span><span style="display:flex;"><span>  derived() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;derived&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">new</span>(<span style="color:#66d9ef">this</span>) base(); <span style="color:#75715e">// line 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明一个对象 <code>derived d</code>，则会打印出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>base
</span></span><span style="display:flex;"><span>derived
</span></span><span style="display:flex;"><span>base
</span></span></code></pre></div><p><code>derived</code> 的构造函数执行时，其继承的基类 <code>base</code> 的构造函数已经执行完毕，
后续第 10 行再次执行里 <code>base</code> 的构造函数。</p>
<p>这种用法需要注意两个问题：</p>
<ol>
<li>如果第 10 行是 <code>new(this) derived()</code>, 就会重复调用构造函数自身造成堆栈溢出 &ndash; 不要在构造函数里使用；</li>
<li>如果 <code>this</code> 实例的成员变量包含动态分配的内存，则会发生内存泄漏。</li>
</ol>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>进一步的分类可参考 <a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">value category</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>需要指定<code>-fno-elide-constructors</code>，否则将因为 RVO 优化而只会调用一次构造函数。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>参考 <a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" target="_blank" rel="noopener">C++ rvalue references and move semantics for beginners</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>参考 <a href="https://stackoverflow.com/a/3582313/3296421" target="_blank" rel="noopener">https://stackoverflow.com/a/3582313/3296421</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>

    
        <div class="tags">
            
                <a href="https://live4thee.github.io/tags/c&#43;&#43;">c&#43;&#43;</a>
            
        </div>
    
    
    
  <div id="comment">
    
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "live4thee" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>


</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://www.facebook.com/live4thee" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Facebook</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-152.000000, -43.000000)">
            <g id="Facebook" transform="translate(152.000000, 43.000000)">
                <rect id="Rounded" fill="#bbbbbb" x="0" y="0" width="72" height="72" rx="8"></rect>
                <path d="M60.4641463,13.4173171 L60.4641463,22.7278049 L54.9382927,22.7421951 C50.6068293,22.7421951 49.7721951,24.8 49.7721951,27.807561 L49.7721951,34.4702439 L60.09,34.4702439 L58.7517073,44.8887805 L49.7721951,44.8887805 L49.7721951,72 L39.0097317,72 L39.0097317,44.8887805 L30,44.8887805 L30,34.4702439 L39.0097317,34.4702439 L39.0097317,26.7858537 C39.0097317,17.8639024 44.4478049,13 52.42,13 C56.2204634,13 59.5,13.2878049 60.4641463,13.4173171 Z" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://github.com/live4thee" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/live4thee" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2025 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       live4thee
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
