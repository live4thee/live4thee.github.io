<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mm on Life of a Programmer</title>
    <link>https://live4thee.github.io/tags/mm/</link>
    <description>Recent content in Mm on Life of a Programmer</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 21 Feb 2025 09:59:45 +0800</lastBuildDate>
    <atom:link href="https://live4thee.github.io/tags/mm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Signals &amp; Multithreading</title>
      <link>https://live4thee.github.io/posts/2025-02-21-signals-and-multithreading/</link>
      <pubDate>Fri, 21 Feb 2025 09:59:45 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2025-02-21-signals-and-multithreading/</guid>
      <description>最近研究进程的退出，进而弄清楚了一些信号方面的疑问。首先开宗明义：“多线程进程中，信号由主线程处理” 这句话是不准确的。 进程为何退出？ 🔗想要跟</description>
    </item>
    <item>
      <title>trace-cmd et al</title>
      <link>https://live4thee.github.io/posts/2025-02-19-trace-cmd-et-al/</link>
      <pubDate>Wed, 19 Feb 2025 18:24:25 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2025-02-19-trace-cmd-et-al/</guid>
      <description>bpftrace 固然好用，但有时候环境中没法装。此时，使用 ftrace 是个很好的选择。具体做法： 使用 trace-cmd, 跟踪内核耗时是个不错的选择； 直接使用 tracefs 接口，最好对照内核文档；</description>
    </item>
    <item>
      <title>Recap</title>
      <link>https://live4thee.github.io/posts/2025-02-05-recap/</link>
      <pubDate>Wed, 05 Feb 2025 11:00:59 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2025-02-05-recap/</guid>
      <description>又是新的一年，记录一下去年碰到、但尚未解决的问题。 悬而未决 🔗fsync(2) 🔗假设有以下代码： int fd1, fd2; fd1 = open(&amp;#34;file&amp;#34;, O_CREAT|O_RDWR); do_write(fd1); close(fd1); fd2 = open(&amp;#34;file&amp;#34;, O_CREAT|O_RDWR); fsync(fd2); fsync(fd2) 会回写因 fd1 而写入</description>
    </item>
    <item>
      <title>Notes on Unknown (2)</title>
      <link>https://live4thee.github.io/posts/2024-11-20-notes-on-unknown-2/</link>
      <pubDate>Wed, 20 Nov 2024 10:02:51 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-11-20-notes-on-unknown-2/</guid>
      <description>天渐冷 🔗本月跑量目前已经 84.3 公里，灵白魔鬼线山路徒步 8 公里， 其中还有一段比较陡峭的崖降。刺激。 小本本 🔗vmscan 问题 🔗请教了F老师后，奇怪的</description>
    </item>
    <item>
      <title>Notes on Unknown</title>
      <link>https://live4thee.github.io/posts/2024-11-09-notes-on-unknown/</link>
      <pubDate>Sat, 09 Nov 2024 21:41:11 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-11-09-notes-on-unknown/</guid>
      <description>记录一下最近碰到的不能理解的问题。 radix_tree_node 占比 🔗下面是某个节点的例子： $ slabtop -sc --once | sed -e &amp;#39;1,6d&amp;#39; -e &amp;#39;s/J S/J-S/&amp;#39; -e &amp;#39;s/E S/E-S/&amp;#39; | head -10 | column -t OBJS ACTIVE USE OBJ-SIZE SLABS OBJ/SLAB CACHE-SIZE NAME 4848200 4847571 99% 1.14K 173150 28 5540800K ext4_inode_cache 16624725 16623589</description>
    </item>
    <item>
      <title>Pains &amp; Gains</title>
      <link>https://live4thee.github.io/posts/2024-11-07-pains-and-gains/</link>
      <pubDate>Thu, 07 Nov 2024 21:58:36 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-11-07-pains-and-gains/</guid>
      <description>Pains 🔗Physical 🔗大概十月中旬开始，起床时两手有点麻，无法握拳。差不多一分钟内，症状消失。最近几天左手背开始有点酸疼。 Mental 🔗这两天被 Linux 的内</description>
    </item>
    <item>
      <title>bpftrace Tips</title>
      <link>https://live4thee.github.io/posts/2024-07-25-bpftrace-tips/</link>
      <pubDate>Thu, 25 Jul 2024 18:39:04 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-07-25-bpftrace-tips/</guid>
      <description>bpftrace 的一些陷阱 🔗&amp;ldquo;char[]&amp;rdquo; 的问题 🔗举个例子，xfs_lookup 对应 tracepoint 中的第四个参数 name 被声明为 char[] 而不是 char*. 这在 C 里</description>
    </item>
    <item>
      <title>A Taste of bpftrace</title>
      <link>https://live4thee.github.io/posts/2024-01-09-a-taste-of-bpftrace/</link>
      <pubDate>Tue, 09 Jan 2024 13:03:35 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-01-09-a-taste-of-bpftrace/</guid>
      <description>bpftrace真的挺好用。1 跟踪进程的执行 🔗通过跟踪 execve，可以得到系统中进程执行的情况。 $ bpftrace -e &amp;#39;tracepoint:syscalls:sys_enter_execve { time(&amp;#34;%H:%M:%S &amp;#34;); join(args-&amp;gt;argv) }&amp;#39; Attaching 1 probe... 13:10:04 /usr/lib64/sa/sa1 1 1 13:10:04 /usr/lib64/sa/sadc -F -L -S</description>
    </item>
    <item>
      <title>Interpreting Kernel Call Trace</title>
      <link>https://live4thee.github.io/posts/2024-01-02-interpreting-kernel-call-trace/</link>
      <pubDate>Tue, 02 Jan 2024 16:54:12 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2024-01-02-interpreting-kernel-call-trace/</guid>
      <description>假设有 Call Trace 如下： [89580.077835] task:kworker/u195:0 state:D stack: 0 pid:9848 ppid: 2 flags:0x80004080 [89580.077840] Workqueue: events_unbound async_run_entry_fn [89580.077845] Call Trace: [89580.077847] __schedule+0x2d1/0x860 [89580.077852] ? scan_shadow_nodes+0x30/0x30 [89580.077856] schedule+0x35/0xa0 [89580.077857] io_schedule+0x12/0x40 [89580.077859] do_read_cache_page+0x4eb/0x740 上面这段日志是由 kernel/sched/core.c 中的 sched_show_task() 函数打印的。 任务信息 🔗task:kworker</description>
    </item>
    <item>
      <title>Interpreting Linux OOM Logs (1/2)</title>
      <link>https://live4thee.github.io/posts/2019-04-12-interpreting-linux-oom-logs/</link>
      <pubDate>Fri, 12 Apr 2019 10:28:42 +0800</pubDate>
      <guid>https://live4thee.github.io/posts/2019-04-12-interpreting-linux-oom-logs/</guid>
      <description>本文描述如何分析 Linux OOM 日志。下面的日志去掉了开头的时间戳。 HOST1 kernel: prometheus invoked oom-killer: gfp_mask=0x0, order=0, oom_score_adj=0 HOST1 kernel: prometheus cpuset=docker-f55e8d749684a0746aa1cb3d186df370848ba502cc19d249bf732450de5a2f30.scope mems_allowed=0-3 HOST1 kernel: CPU: 88 PID: 49521 Comm: prometheus Tainted: G OE ------------ 3.10.0-327.36.1.el7.x86_64 #1 HOST1 kernel: Hardware name: Dell Inc. PowerEdge R930/0Y0V4F, BIOS 2.4.3 07/07/2017 HOST1 kernel: ffff88bf0612f300 00000000cbfaa699</description>
    </item>
  </channel>
</rss>
